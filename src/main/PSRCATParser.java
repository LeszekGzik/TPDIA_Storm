package bolts;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStreamReader;
import java.util.List;

import org.apache.commons.lang.SerializationUtils;

//public class PSRCATParser {
//
//}

/*
************************************************************

 PSRCATParser.py

************************************************************
 Description:

 Parses an ANTF pulsar catalog file.

************************************************************
 Author: Rob Lyon
 Email : robert.lyon@manchester.ac.uk
 web   : www.scienceguyrob.com
************************************************************
 License:

 Code made available under the GPLv3 (GNU General Public
 License), that allows you to copy, modify and redistribute
 the code as you see fit:

 http://www.gnu.org/copyleft/gpl.html

 Though a mention to the original author using the citation
 above in derivative works, would be very much appreciated.
************************************************************
*/
import spouts.PSRCATEntry;
// ******************************
//
// CLASS DEFINITION
//
// ******************************

public class PSRCATParser{
   
    //Parses an ATNF pulsar catalog database file.
    

    // ******************************
    //
    // Methods
    //
    // ******************************

    public static List<PSRCATEntry> parse_as_list(String path) {
        /*
        Parses an ATNF pulsar catalog file. It returns the
        contents as a list of PSRCATEntry objects.

        Parameters
        ----------
        :param path: the full path to the catalog file to
        parse.

        Returns
        ----------
        :return: a list of PSRCATEntry objects if the file
        can be parsed, else None.

        Examples
        --------
        >>> e = PSRCATParser.parse_as_list('/data/cat.db')
        >>> print len(e)
        2524
        */

        if (!PSRCATParser.file_exists(path))
            return null;

        // Stores the objects correctly parsed.
        List<PSRCATEntry>atnf_srcs = null;

        if (PSRCATParser.is_catalogue_file(path)) {
        	try {
        	//File psr_cat = new File(path);
        	FileInputStream fstream = new FileInputStream(path);
        	BufferedReader br = new BufferedReader(new InputStreamReader(fstream));
            // A temporary object that is used create new
            // PSRCATEntry instances.
        	PSRCATEntry atnf_src;// = new PSRCATEntry();

            // The ATNF catalog file contains entries
            // delimited by the following lines:
            //
            // // CATALOGUE 1.54
            // //
            // // DO NOT EDIT THIS FILE!
            // //
            // @-------------------------------------------
            //
            // For example:
            //
            // PSRJ     J0001+0001                  cnt96
            // RAJ      00:00:00.0               2  cn95
            // DECJ     +00:00:00                4  cn95
            // P0       0.69374767047            14 cn95
            // P1       2.097E-15                12 cn95
            // PEPOCH   49079.5                     cn95
            // DM       12.0                     6  cn95
            // S400     0.2                         cn95
            // W50      82                          cn95
            // W10      195                         cn95
            // @-------------------------------------------
            // PSRJ     J0002+0002                  aaa+09c
            // RAJ      00:10:00                 2  awd+12
            // DECJ     +00:00:00                8  awd+12
            // DM       10.0                     2  AWD+12
            // F0       3.165827392              3  awd+12
            // F1       -3.6120E-12              5  awd+12
            // F2       4.1E-23                  7  awd+12
            // F3       5.4E-30                  9  awd+12
            // @-------------------------------------------
            // PSRJ     J0003+0003                  dth78
            // RAJ      10:00:00                 4  hlk+04
            //
            // ....
            //
            // Thus here we should ignore lines beginning
            // with '//', and should build a new source after
            // seeing lines beginning with:
            //
            // @----
        	String strLine;
        	while((strLine = br.readLine()) != null) {
        		
        		atnf_src = new PSRCATEntry(); 
        		
       			if(strLine.charAt(0) == '#') {
                    // Ignore these lines.
                    continue;
                }
                else
                	if(strLine.charAt(0) == '@') {

                    // This signals the end of the current
                    // source. Add the current PSRCATEntry
                    // object to the known source dictionary
                    // and clean up.
                    atnf_srcs.add(atnf_src);
                	//atnf_srcs.append( copy.deepcopy(atnf_src));
                    //atnf_srcs.add((PSRCATEntry)SerializationUtils.clone(atnf_src));
                    
                		// Simply resets the temporary object. 
                    // Does not initialise a new object, 
                    // thus saving CPU overhead (although 
                    // minuscule, it all adds up).
                    // atnf_src.sourceParameters.clear();
                    //atnf_src.sourceName = "Unknown";
                	}
                	else
                		if(strLine.length() > 2) {
                			// If the line doesn't begin with '//' 
                            // or '@' and isn't an empty line, then
                            // process it.
                			atnf_src.process_atnf_formatted_line(strLine);
                		}
                		else 
                			continue;  // else ignore
                		
            }
        	
        	fstream.close();
        	br.close();
        	} catch (Exception e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
        }

        return atnf_srcs;
    }
    // ******************************************************

    public static boolean is_catalogue_file(String path) {
        /*
        Checks if the file at the supplied path is a catalog
        file. Returns true if the file is a catalog file, 
        else false. This is a rather dumb check procedure, 
        but for now it would be overkill to check the 
        complete structure of the file. If you want, you can 
        improve this!

        Parameters
        ----------
        :param path: the full path to the potential 
            catalog file.

        Returns
        ----------
        True if the specified file is a catalog file, 
            else false.

        Examples
        --------
        >>> e = PSRCATParser.is_catalogue_file('psrcat.db')
        True

        */
    	File tmpFile = new File(path);
    	return tmpFile.isDirectory();
       
    }
    // ******************************************************

 
    public static boolean file_exists(String path) {
        /*
        Checks a file exists, returns true if it does, 
        else false.

        Parameters
        ----------
        :param path: the path to the file.

        Returns
        ----------
        :return: True if the file exists, else false.

        */
    	return (new File(path)).exists();
        
    }
    // ******************************************************
}